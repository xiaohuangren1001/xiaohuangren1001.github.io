
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../22-first-app/">
      
      
        <link rel="next" href="../24-c-app-part1/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.44">
    
    
      
        <title>23 C语言应用程序（上） - Oildum/Atklom's Blog</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.0253249f.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../assets/style.css">
    
      <link rel="stylesheet" href="../../../assets/highlight.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Oildum/Atklom&#39;s Blog" class="md-header__button md-logo" aria-label="Oildum/Atklom's Blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Oildum/Atklom's Blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              23 C语言应用程序（上）
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  主页

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
    
  
  操作系统教程

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Oildum/Atklom&#39;s Blog" class="md-nav__button md-logo" aria-label="Oildum/Atklom's Blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Oildum/Atklom's Blog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    主页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    操作系统教程
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            操作系统教程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    旧教程
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            旧教程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../00-beforestart/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    00 开始之前
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-first-boot-sector/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    01 第一个引导扇区
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-fat12-file-system/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    02 创建 FAT12 文件系统
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-find-loader/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    03 查找 Loader
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-load-and-jump-into-loader/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    04 加载并跳入 Loader
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-read-kernel-and-into-32/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    05 读取内核并进入保护模式
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../06-relocate-and-jump-into-kernel/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    06 重新放置内核并进入内核
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../07-print-impl/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    07 实现我们自己的打印函数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../08-we-love-makefile/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    08 整理文件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../09-gdtidt/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    09 重设 GDT、IDT
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../10-irq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    10 接收外部中断，从时钟开始
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../11-seg-memman/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    11 段式内存管理的实现
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../12-multitasking/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    12 多任务
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../13-kbd-part0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    13 终于可以打字了——键盘驱动（上）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../14-kbd-part1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    14 终于可以打字了——键盘驱动（下）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../15-syscall/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    15 系统调用——应用程序与系统的交互之门
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../16-shell-d-and-i/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    16 shell的设计与实现
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../17-fat16-part0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    17 实现FAT16文件系统（1）——基础设施建设：硬盘驱动、RTC
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../18-fat16-part1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    18 实现FAT16文件系统（2）——格式化、打开文件、创建文件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../19-fat16-part2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    19 实现FAT16文件系统（3）——读取文件、写入文件、删除文件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../20-fat16-part3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    20 实现FAT16文件系统（4）——上层包装
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../21-fat16-part4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    21 FAT16 文件系统实战——抛弃软盘，从硬盘启动
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../22-first-app/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    22 第一个应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    23 C语言应用程序（上）
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../24-c-app-part1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    24 C语言应用程序（下）
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../new/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    新教程
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            新教程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>23 C语言应用程序（上）</h1>

<p>终于要结束啦（超大声）</p>
<p>本节先来处理上一节的历史遗留问题，上一节给我们留下了一个巨大的烂摊子：</p>
<blockquote>
<p>系统调用中有关应用程序基址偏移的部分需要对不同的系统调用具体问题具体分析，这意味着把那个优美的系统调用表拆成一坨屎一样的 switch-case。</p>
<p>执行应用程序还没有集成到 shell。事实上这个功能看上去容易，其实也略有复杂，还有两个系统调用（<code>waitpid</code> 和 <code>exit</code>）没有实现。</p>
</blockquote>
<p>单是解决这两个问题可能就要耗去一半的篇幅了，留给我们的时间不多了呀。</p>
<p>首先我们来把系统调用表拆掉。其实这个东西命不该绝，拆了也会让代码变得很丑，但是为了应用程序的执行，我们也只好挥泪斩马谡，对系统调用表高唱 see you again。现在的 <code>syscall.h</code> 长这样：</p>
<p><strong>代码 23-1 想你了系统调用表（include/syscall.h）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef _SYSCALL_H_</span>
<span class="cp">#define _SYSCALL_H_</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">sys_getpid</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_create_process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">app_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cmdline</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">work_dir</span><span class="p">);</span>

<span class="c1">// file.h</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_open</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_write</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_read</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_close</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_lseek</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">whence</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sys_unlink</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">);</span>

<span class="cp">#endif</span>
</code></pre></div></p>
<p>或许在声明中还看不出什么，你看一眼实现就明白了：</p>
<p><strong>代码 23-2 想你了系统调用表-实现版（kernel/syscall.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">syscall_manager</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">esi</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ebp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">esp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">edx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ecx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">eax</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ds_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_now</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ds_base</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">eax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 从这里开始</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_getpid</span><span class="p">();</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_write</span><span class="p">(</span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ecx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_read</span><span class="p">(</span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ecx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_create_process</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ebx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ecx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">edx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// 到这里结束</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">save_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eax</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">save_reg</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>和原来相比简直丑的不止一点半点。不过对于程序来说最重要的还是能不能跑，这点美学上的牺牲可以不管。</p>
<p>在接入到 shell 之前，我们还得实现点系统调用。首先是文件系统的全套，其次是 <code>waitpid</code> 和 <code>exit</code>。还好，这些东西的底层实现我们都已经有了：</p>
<p><strong>代码 23-3 系统调用大爆炸（kernel/syscall.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">syscall_manager</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">esi</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ebp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">esp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">edx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ecx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">eax</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ds_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_now</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ds_base</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">eax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_getpid</span><span class="p">();</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_write</span><span class="p">(</span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ecx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_read</span><span class="p">(</span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ecx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="c1">// 从这里开始</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_open</span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ebx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="n">ecx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_close</span><span class="p">(</span><span class="n">ebx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_lseek</span><span class="p">(</span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="n">ecx</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">6</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_unlink</span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ebx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">7</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_create_process</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ebx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">ecx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">edx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ds_base</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">8</span><span class="p">:</span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_wait</span><span class="p">(</span><span class="n">ebx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mi">9</span><span class="p">:</span>
<span class="w">            </span><span class="n">task_exit</span><span class="p">(</span><span class="n">ebx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// 到这里结束</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">save_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eax</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">save_reg</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>为了把文件系统相关放到一块，这里把 <code>create_process</code> 向后推了一段距离。这些系统调用对应的高级接口如下：</p>
<p><strong>代码 23-4 系统调用高层实现（kernel/syscall_impl.asm）</strong>
<div class="highlight"><pre><span></span><code><span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">open</span><span class="p">]</span>
<span class="nl">open:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">12</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">close</span><span class="p">]</span>
<span class="nl">close:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">lseek</span><span class="p">]</span>
<span class="nl">lseek:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">12</span><span class="p">]</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">unlink</span><span class="p">]</span>
<span class="nl">unlink:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">create_process</span><span class="p">]</span>
<span class="nl">create_process:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">12</span><span class="p">]</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">waitpid</span><span class="p">]</span>
<span class="nl">waitpid:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="err">[</span><span class="nf">global</span><span class="w"> </span><span class="no">exit</span><span class="p">]</span>
<span class="nl">exit:</span>
<span class="w">    </span><span class="nf">push</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">esp</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>
<span class="w">    </span><span class="nf">pop</span><span class="w"> </span><span class="no">ebx</span>
<span class="w">    </span><span class="nf">ret</span>
</code></pre></div></p>
<p>原来的 <code>create_process</code> 就可以删除了。</p>
<p>现在，我们终于具备了把应用程序执行集成到 shell 当中的条件，是时候开搞了。</p>
<p>首先，在 <code>sys_create_process</code> 中，我们对应用程序是否存在不加任何判断，如果文件不存在的话，拖到 <code>app_entry</code> 再处理就晚了。因此，在创建任务之前，我们先试图打开文件以判断它是否存在：</p>
<p><strong>代码 23-5 文件存在吗？（kernel/exec.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sys_create_process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">app_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cmdline</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">work_dir</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_open</span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">app_name</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">sys_close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 下略</span>
<span class="p">}</span>
</code></pre></div></p>
<p>当文件不存在时，<code>sys_create_process</code> 返回-1。</p>
<p>然后，我们需要在内核主程序中解放 shell，自从第16节起就被封存的 shell 终于派上用场了：</p>
<p><strong>代码 23-6 内核主程序之终（kernel/main.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">kernel_main</span><span class="p">()</span><span class="w"> </span><span class="c1">// kernel.asm会跳转到这里</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">monitor_clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">init_gdtidt</span><span class="p">();</span>
<span class="w">    </span><span class="n">init_memory</span><span class="p">();</span>
<span class="w">    </span><span class="n">init_timer</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="w">    </span><span class="n">init_keyboard</span><span class="p">();</span>
<span class="w">    </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;sti&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">task_t</span><span class="w"> </span><span class="o">*</span><span class="n">task_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task_init</span><span class="p">();</span>
<span class="w">    </span><span class="n">task_t</span><span class="w"> </span><span class="o">*</span><span class="n">task_shell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_kernel_task</span><span class="p">(</span><span class="n">shell</span><span class="p">);</span>
<span class="w">    </span><span class="n">task_run</span><span class="p">(</span><span class="n">task_shell</span><span class="p">);</span>

<span class="w">    </span><span class="n">task_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>在启动了 shell 任务以后，内核主程序旋即退出，并使用 0 的返回值报告正常。内核主程序以后大概还会再改最后一次，事了拂衣去，深藏身与名（泪目）</p>
<p>实现命令执行的函数位于 <code>cmd_execute</code>，因此需要在 <code>cmd_execute</code> 中启动应用程序。哪些是应用程序呢？我们认为只要不是内部命令的就都是应用程序（笑）。</p>
<p><strong>代码 23-7 应用程序执行框架（kernel/shell.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">cmd_execute</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;ver&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cmd_ver</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">exist</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_to_run_external</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exist</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">exist</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;shell: `%s` is not recognized as an internal or external command or executable file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;shell: app `%s` exited abnormally, retval: %d (0x%x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>由于应用程序可能返回任何返回值，所以这里必须使用两个返回值，因此使用传统的指针双返回值法，传一个指针进去表示文件是否存在。如果不存在，自然要报错，这个报错是从 Windows cmd 里抄的；否则，如果返回值不为 0，我们也报一个错，说明应用程序异常退出。</p>
<p>接下来的 <code>try_to_run_external</code> 自然就是实现应用程序执行的核心逻辑了：</p>
<p><strong>代码 23-8 应用程序执行（kernel/shell.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">try_to_run_external</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">exist</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_process</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">cmd_line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 尝试执行应用程序</span>
<span class="w">    </span><span class="o">*</span><span class="n">exist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 文件不存在</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 哇真的不存在</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">new_name</span><span class="p">[</span><span class="n">MAX_CMD_LEN</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"> </span><span class="c1">// 由于还没有实现malloc，所以只能这么搞，反正文件最长就是MAX_CMD_LEN这么长</span>
<span class="w">        </span><span class="n">strcpy</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"> </span><span class="c1">// 复制文件名</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w"> </span><span class="c1">// 文件名结束位置</span>
<span class="w">        </span><span class="n">new_name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 给后</span>
<span class="w">        </span><span class="n">new_name</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 缀加</span>
<span class="w">        </span><span class="n">new_name</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;i&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 上个</span>
<span class="w">        </span><span class="n">new_name</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// .bin</span>
<span class="w">        </span><span class="n">new_name</span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 结束符</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_process</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span><span class="w"> </span><span class="n">cmd_line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 第二次尝试执行应用程序</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 文件还是不存在，那只能不存在了</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">exist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错怪你了，文件存在</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">waitpid</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span><span class="w"> </span><span class="c1">// 等待直到这个pid的进程返回并拿到结果</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"> </span><span class="c1">// 把返回值返回回去</span>
<span class="p">}</span>
</code></pre></div></p>
<p>整体逻辑应该挺好理解的。这里使用了一些新的系统调用，我们新建一个 <code>unistd.h</code> 存放系统调用声明：</p>
<p><strong>代码 23-9 TutorialOS 系统调用列表（include/unistd.h）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef _UNISTD_H_</span>
<span class="cp">#define _UNISTD_H_</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">whence</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">unlink</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">waitpid</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">exit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">create_process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">app_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cmdline</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">work_dir</span><span class="p">);</span>

<span class="cp">#endif</span>
</code></pre></div></p>
<p>在 <code>shell.h</code> 中包含 <code>unistd.h</code> 即可。</p>
<p>最后就是应用程序这边，要使用新的 <code>exit</code> 系统调用退出：</p>
<p><strong>代码 23-10 应用程序（test_app.asm）</strong>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="nf">bits</span><span class="w"> </span><span class="mi">32</span>

<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="no">string</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="no">strlen</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>

<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">114514</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="mi">80</span><span class="no">h</span>

<span class="w">    </span><span class="nf">jmp</span><span class="w"> </span><span class="no">$</span>

<span class="nl">string:</span><span class="w"> </span><span class="nf">db</span><span class="w"> </span><span class="err">&quot;</span><span class="no">Hello</span><span class="p">,</span><span class="w"> </span><span class="no">World</span><span class="p">!</span><span class="err">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0x0A</span><span class="p">,</span><span class="w"> </span><span class="mi">0x00</span>
<span class="nf">strlen</span><span class="w"> </span><span class="no">equ</span><span class="w"> </span><span class="no">$</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="no">string</span>
</code></pre></div></p>
<p>之所以加上 <code>bits 32</code>，是因为我们测试用的返回值（114514）超过16位最大值（65536），所以标记一下使用 32 位寄存器，把数字也看成 32 位的。</p>
<p>编译运行，并把 <code>test_app.bin</code> 写入硬盘，效果如下：</p>
<p><img alt="" src="../images/graph-23-1.png" /></p>
<p>（图 23-1 在shell中执行应用程序）</p>
<p>可以看到，<code>loader.bin</code> 的执行虽然被拦下，但是程序却在异常处理程序中卡死了，没有把控制权交回到 shell。如今已经有了多任务，我们只需在 <code>isr.c</code> 中结束当前任务即可：</p>
<p><strong>代码 23-11 发生异常时强制结束应用程序（kernel/isr.c）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;mtask.h&quot;</span>

<span class="c1">// 中略</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">isr_handler</span><span class="p">(</span><span class="n">registers_t</span><span class="w"> </span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;cli&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">monitor_write</span><span class="p">(</span><span class="s">&quot;received interrupt: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">monitor_write_dec</span><span class="p">(</span><span class="n">regs</span><span class="p">.</span><span class="n">int_no</span><span class="p">);</span>
<span class="w">    </span><span class="n">monitor_put</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="n">task_exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 强制退出</span>
<span class="p">}</span>
</code></pre></div></p>
<p>由于在任务结束后会强制切换回 shell，从而重新开启中断，所以最上面的 <code>asm("cli")</code> 不用处理。</p>
<p>现在再试图运行 <code>loader.bin</code>，应该就会把控制权交还给内核了：</p>
<p><img alt="" src="../images/graph-23-2.png" /></p>
<p>（图 23-2 执行中出现异常时强制结束应用程序）</p>
<p>至此，我们终于解决完了上一节留下的烂摊子。<code>kernel.bin</code> 没被拦下是因为它是有格式的，还没来得及执行到指令就已经不知道在执行什么东西了，从而导致了它的卡死。正好我们本节的任务——C语言应用程序还没开始，就顺其自然，解析 <code>kernel.bin</code> 的文件格式——ELF。重回第 6 节既视感（</p>
<p>重提一下 ELF 文件的结构：</p>
<p><img alt="" src="../images/graph-6-1.png" /></p>
<p>（图 23-3 <code>ELF</code> 文件结构）</p>
<p><strong>代码 23-12 <code>Program Header</code>（include/elf.h）</strong>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">p_type</span><span class="p">;</span><span class="w">   </span><span class="c1">// 当前header描述的段类型</span>
<span class="w">    </span><span class="n">Elf32_Off</span><span class="w">  </span><span class="n">p_offset</span><span class="p">;</span><span class="w"> </span><span class="c1">// 段的第一个字节在文件中的偏移</span>
<span class="w">    </span><span class="n">Elf32_Addr</span><span class="w"> </span><span class="n">p_vaddr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 段在内存中的虚拟地址</span>
<span class="w">    </span><span class="n">Elf32_Addr</span><span class="w"> </span><span class="n">p_paddr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 段在内存中的物理地址，为兼容不进入保护模式的OS</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">p_filesz</span><span class="p">;</span><span class="w"> </span><span class="c1">// 段在文件中的长度</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">p_memsz</span><span class="p">;</span><span class="w">  </span><span class="c1">// 段在内存中的长度</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">p_flags</span><span class="p">;</span><span class="w">  </span><span class="c1">// 与段相关的标志</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">p_align</span><span class="p">;</span><span class="w">  </span><span class="c1">// 确定段在文件和内存中如何对齐</span>
<span class="p">}</span><span class="w"> </span><span class="n">Elf32_Phdr</span><span class="p">;</span>
</code></pre></div></p>
<p><strong>代码 23-13 ELF 头（include/elf.h）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#define EI_NIDENT 16</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_NIDENT</span><span class="p">];</span><span class="w"> </span><span class="c1">// ELF特征标</span>

<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_type</span><span class="p">;</span><span class="w">      </span><span class="c1">// 文件类型</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_machine</span><span class="p">;</span><span class="w">   </span><span class="c1">// 运行至少需要的体系结构</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">e_version</span><span class="p">;</span><span class="w">   </span><span class="c1">// 文件版本</span>
<span class="w">    </span><span class="n">Elf32_Addr</span><span class="w"> </span><span class="n">e_entry</span><span class="p">;</span><span class="w">     </span><span class="c1">// 程序的入口点</span>
<span class="w">    </span><span class="n">Elf32_Off</span><span class="w">  </span><span class="n">e_phoff</span><span class="p">;</span><span class="w">     </span><span class="c1">// Program Header 表的偏移</span>
<span class="w">    </span><span class="n">Elf32_Off</span><span class="w">  </span><span class="n">e_shoff</span><span class="p">;</span><span class="w">     </span><span class="c1">// Section Header 表的偏移</span>
<span class="w">    </span><span class="n">Elf32_Word</span><span class="w"> </span><span class="n">e_flags</span><span class="p">;</span><span class="w">     </span><span class="c1">// 对于32位系统为0</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_ehsize</span><span class="p">;</span><span class="w">    </span><span class="c1">// ELF Header 的大小，单位字节</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_phentsize</span><span class="p">;</span><span class="w"> </span><span class="c1">// Program Header 的大小</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_phnum</span><span class="p">;</span><span class="w">     </span><span class="c1">// Program Header 的数量</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_shentsize</span><span class="p">;</span><span class="w"> </span><span class="c1">// Section Header 的大小</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_shnum</span><span class="p">;</span><span class="w">     </span><span class="c1">// Section Header 的数量</span>
<span class="w">    </span><span class="n">Elf32_Half</span><span class="w"> </span><span class="n">e_shstrndx</span><span class="p">;</span><span class="w">  </span><span class="c1">// 包含 Section 名称的字符串表位于哪一项</span>
<span class="p">}</span><span class="w"> </span><span class="n">Elf32_Ehdr</span><span class="p">;</span>
</code></pre></div></p>
<p>其中数据类型 Elf32_Word、Elf32_Off 和 Elf32_Addr 均为大小为 4、对齐也为 4 的无符号类型，而 Word 为大整数，Off 为偏移，Addr 为地址。Half 则顾名思义，是前面这些类型的一半，也就是 2 个字节这么大。因此，在文件开头添加这样的类型定义：</p>
<p><strong>代码 23-14 类型定义（include/elf.h）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef _ELF_H_</span>
<span class="cp">#define _ELF_H_</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;common.h&quot;</span>

<span class="cp">#define PT_LOAD 1</span>

<span class="cp">#define EI_NIDENT 16</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Elf32_Word</span><span class="p">,</span><span class="w"> </span><span class="n">Elf32_Off</span><span class="p">,</span><span class="w"> </span><span class="n">Elf32_Addr</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Elf32_Half</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="cp">#endif</span>
</code></pre></div></p>
<p>与程序执行直接相关的只有 <code>Program Header</code>，利用它们头中给定的地址把分割成几个部分的程序依次排列在内存中，ELF 解析工作就完成了，接下来从 ELF 头给定的入口点开始执行即可。</p>
<p>（严格来讲其实要做的远比这个要多，什么动态链接、调试符号之类的都要解析 Section Header，但是我们只做最基本的执行的话就不强求了）</p>
<p>那么，我们就来快速地解析一下 ELF 文件。首先新建一个 <code>kernel/elf.c</code>：</p>
<p><strong>代码 23-15 准备开始解析 ELF（kernel/elf.c）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;elf.h&quot;</span>

<span class="cp">#define min(a, b) ((a) &lt; (b) ? (a) : (b))</span>
<span class="cp">#define max(a, b) ((a) &lt; (b) ? (b) : (a))</span>
</code></pre></div></p>
<p>这里定义了两个一看就懂的宏 <code>max</code> 和 <code>min</code>，个人认为不用解释。</p>
<p>接下来我们就开始准备加载 ELF 了。出于简单的需要，我们把可执行程序的入口点定在 0x00 处；由于这个要求完全做不到，链接器就会自己把整个代码段的开始位置定在这里，然后把入口点略微往后推一点点。既然这样，鉴于这个程序如果直接加载到内存，将位于 1MB 以内，而这一块内存我们根本就不想管，所以我们要另行分配一个缓冲区作为 ELF 解析后的存放地。</p>
<p>那么，知道这个 ELF 在被解析后一共多大就尤为重要了。事实上，这个过程可以在被解析之前进行，只需要遍历每一个 Program Header，同时更新加载首地址最小值与末地址最大值，最后减一下就可以了：</p>
<p><strong>代码 23-16 获取 ELF 被加载后的范围（kernel/elf.c）</strong>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">calc_load_range</span><span class="p">(</span><span class="n">Elf32_Ehdr</span><span class="w"> </span><span class="o">*</span><span class="n">ehdr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Elf32_Phdr</span><span class="w"> </span><span class="o">*</span><span class="n">phdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Elf32_Phdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">ehdr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span><span class="w"> </span><span class="c1">// 第一个 program header 地址</span>
<span class="w">    </span><span class="o">*</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span><span class="w"> </span><span class="c1">// UINT32最大值</span>
<span class="w">    </span><span class="o">*</span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// UINT32最小值</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 遍历每一个 program header</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">PT_LOAD</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="c1">// 只关心LOAD段</span>
<span class="w">        </span><span class="o">*</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_vaddr</span><span class="p">);</span>
<span class="w">        </span><span class="o">*</span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_vaddr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_memsz</span><span class="p">);</span><span class="w"> </span><span class="c1">// 每一个program header首尾取最值</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>在 ELF 头中放着的 <code>e_phoff</code> 代表第一个 Program Header 的相对 ELF 头的偏移，加上 ELF 头的地址，就得到了第一个 Program Header 的地址。由前面的结构图可以知道，所有的 Program Header 是连续的，因此可以被视为一个数组，其长度则由 ELF 头的 <code>e_phnum</code> 定义。在这么多 Program Header 中，只有类型为 <code>PT_LOAD</code>（其值为 1，在 include/elf.h 中定义）才可以加载，因此我们也就只管这些。这里还是使用经典的指针法进行多值返回。</p>
<p>在获取范围以后就可以分配缓冲区了。假设现在已经分配好了缓冲区，我们要把每个 Program Header 所对应的程序复制到正确的位置去，这就需要知道它们的大小和 <del>方向</del> 位置。位置比较容易，Program Header 的 <code>p_offset</code> 存的就是相对 ELF 头的位置；大小却有 <code>p_memsz</code> 和 <code>p_filesz</code> 两个值，采信哪个呢？由于我们是要从文件里加载，所以采用 <code>p_filesz</code> 的值，至于可能多出来的部分，那就只能填 0 了。</p>
<p><strong>代码 23-17 复制 ELF 的各个 Program Header（kernel/elf.c）</strong>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">copy_load_segments</span><span class="p">(</span><span class="n">Elf32_Ehdr</span><span class="w"> </span><span class="o">*</span><span class="n">ehdr</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Elf32_Phdr</span><span class="w"> </span><span class="o">*</span><span class="n">phdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Elf32_Phdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">ehdr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span><span class="w"> </span><span class="c1">// 第一个 program header 地址</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 遍历每一个 program header</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">PT_LOAD</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="c1">// 只关心LOAD段</span>

<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">segm_in_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">ehdr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_offset</span><span class="p">;</span><span class="w"> </span><span class="c1">// 段在文件中的位置</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_vaddr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">segm_in_file</span><span class="p">,</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_filesz</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将文件中大小的部分copy过去</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">remain_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_memsz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_filesz</span><span class="p">;</span><span class="w"> </span><span class="c1">// 两者之差</span>
<span class="w">        </span><span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_vaddr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">phdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_filesz</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">remain_bytes</span><span class="p">);</span><span class="w"> </span><span class="c1">// 赋值为0</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>最后便是融合到一起去的整体包装，它会首先检测 ELF 格式是否正确，如果错误会返回 -1，否则返回 ELF 的入口点，也就是开始执行的位置：</p>
<p><strong>代码 23-18 加载 ELF（kernel/elf.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">load_elf</span><span class="p">(</span><span class="n">Elf32_Ehdr</span><span class="w"> </span><span class="o">*</span><span class="n">ehdr</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\177</span><span class="s">ELF</span><span class="se">\1\1\1</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 魔数不对，不予执行</span>
<span class="w">    </span><span class="n">calc_load_range</span><span class="p">(</span><span class="n">ehdr</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">);</span><span class="w"> </span><span class="c1">// 计算加载位移</span>
<span class="w">    </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 用算得的大小分配内存</span>
<span class="w">    </span><span class="n">copy_load_segments</span><span class="p">(</span><span class="n">ehdr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="c1">// 把 ELF </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>ELF 头的作用不必多说，这里之所以用两重指针，是因为我们要修改单重指针 <code>buf</code> 的值。在实际使用时只要传一个指针进来就行了，不管这个指针长什么样子。</p>
<p>这样一来，在 buf 中存着的就是二进制一样的机器码了，理论上可以直接启动。事实上也的确如此，在 exec.c 中只需修改几行代码，就可以让一个 ELF 跑起来了：</p>
<p><strong>代码 23-19 启动 ELF（kernel/exec.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">app_entry</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">app_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cmdline</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">work_dir</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ...上略...</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">code</span><span class="p">;</span><span class="w"> </span><span class="c1">// 存放代码的缓冲区</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_elf</span><span class="p">((</span><span class="n">Elf32_Ehdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">last</span><span class="p">);</span><span class="w"> </span><span class="c1">// buf是文件读进来的那个缓冲区，code是存实际代码的</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">task_exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 解析失败，直接exit(-1)</span>
<span class="w">    </span><span class="c1">// 注意：以下代码非常不安全，仅供参考；不过目前我也没有找到更优的解</span>
<span class="w">    </span><span class="c1">// 坑比 intel 在访问 [esp + xxx] 的地址时用的是 ds，ss 完全成了摆设，所以栈和数据必须放在一个段里，于是就炸了</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="n">last</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 新分配一个数据段，为原来大小+4MB+5</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">first</span><span class="p">);</span><span class="w"> </span><span class="c1">// 把代码复制过来，也就包含了必须要用的数据</span>
<span class="w">    </span><span class="n">task_now</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ds_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">ds</span><span class="p">;</span><span class="w"> </span><span class="c1">// 数据段基址，与下面一致</span>
<span class="w">    </span><span class="n">ldt_set_gate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x409a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x60</span><span class="p">);</span>
<span class="w">    </span><span class="n">ldt_set_gate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">ds</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x4092</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x60</span><span class="p">);</span><span class="w"> </span><span class="c1">// 大小也多了4MB</span>
<span class="w">    </span><span class="n">start_app</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">task_now</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">esp0</span><span class="p">));</span><span class="w"> </span><span class="c1">// 把栈顶设为4MB-4</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p>坑比 intel 在访问 [esp + xxx] 的地址时用的是 ds，ss 完全成了摆设，所以栈和数据必须放在一个段里，于是就炸了（重复一遍）。</p>
<p>现在已经可以执行 ELF 了，我们就写一个 C 应用作为测试吧。新建 apps 文件夹，我们就写一个最简单的 Hello World：</p>
<p><strong>代码 23-20 Hello, ELF World!（apps/test_c.c）</strong>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p>不知道看见这样的程序勾起了你什么回忆呢，总之我是有种回到了刚学 C 语言时的感觉……不煽情了，现在仔细回顾一下这个程序，有什么问题吗？</p>
<p>看似完美无缺，实际上问题非常严重。或许你曾对 <code>main</code> 函数的返回值谁来接收有疑问，当时的回答是操作系统。现在我们就是操作系统，那这个 <code>main</code> 的返回值，是不是也得接收一下？</p>
<p>况且在第五节中提过，ELF 程序的真正入口并不是 <code>main</code>，而是 <code>_start</code>，<code>main</code> 只是一个普通的函数而已。因此，我们需要定义一个 <code>_start</code>。</p>
<p>这个 <code>_start</code> 还是相当好写的，让应用程序接收参数是下一节的话题，不考虑参数的话，只需要调用 <code>main</code>，然后用 <code>exit</code> 结束应用程序即可：</p>
<p><strong>代码 23-21 简单的入口点（apps/start.c）</strong>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">();</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">_start</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">main</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></p>
<p>接下来怎么编译呢？直接 <code>gcc</code>？那可不行，我们的“标准库”和 Linux 还是不一样的，得链接上我们的标准库才行。</p>
<p>对 Makefile 这么修改一下：</p>
<p><strong>代码 23-22 新的 Makefile（Makefile）</strong>
<div class="highlight"><pre><span></span><code><span class="nv">LIBC_OBJECTS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>out/syscall_impl.o<span class="w"> </span>out/stdio.o<span class="w"> </span>out/string.o

<span class="nf">out/%.bin </span><span class="o">:</span><span class="w"> </span><span class="n">apps</span>/%.<span class="n">asm</span>
<span class="w">    </span>nasm<span class="w"> </span>apps/<span class="nv">$*</span>.asm<span class="w"> </span>-o<span class="w"> </span>out/<span class="nv">$*</span>.o<span class="w"> </span>-f<span class="w"> </span>elf
<span class="w">    </span>i686-elf-ld<span class="w"> </span>-s<span class="w"> </span>-Ttext<span class="w"> </span>0x0<span class="w"> </span>-o<span class="w"> </span>out/<span class="nv">$*</span>.bin<span class="w"> </span>out/<span class="nv">$*</span>.o

<span class="nf">out/tulibc.a </span><span class="o">:</span><span class="w"> </span><span class="k">$(</span><span class="nv">LIBC_OBJECTS</span><span class="k">)</span>
<span class="w">    </span>i686-elf-ar<span class="w"> </span>rcs<span class="w"> </span>out/tulibc.a<span class="w"> </span><span class="k">$(</span>LIBC_OBJECTS<span class="k">)</span>

<span class="nf">out/%.bin </span><span class="o">:</span><span class="w"> </span><span class="n">apps</span>/%.<span class="n">c</span> <span class="n">apps</span>/<span class="n">start</span>.<span class="n">c</span> <span class="n">out</span>/<span class="n">tulibc</span>.<span class="n">a</span>
<span class="w">    </span>i686-elf-gcc<span class="w"> </span>-c<span class="w"> </span>-I<span class="w"> </span>include<span class="w"> </span>apps/start.c<span class="w"> </span>-o<span class="w"> </span>out/start.o<span class="w"> </span>-fno-builtin
<span class="w">    </span>i686-elf-gcc<span class="w"> </span>-c<span class="w"> </span>-I<span class="w"> </span>include<span class="w"> </span>apps/<span class="nv">$*</span>.c<span class="w"> </span>-o<span class="w"> </span>out/<span class="nv">$*</span>.o<span class="w"> </span>-fno-builtin
<span class="w">    </span>i686-elf-ld<span class="w"> </span>-s<span class="w"> </span>-Ttext<span class="w"> </span>0x0<span class="w"> </span>-o<span class="w"> </span>out/<span class="nv">$*</span>.bin<span class="w"> </span>out/<span class="nv">$*</span>.o<span class="w"> </span>out/start.o<span class="w"> </span>out/tulibc.a
</code></pre></div></p>
<p>这里先用了 <code>ar</code>，把我们的“标准库”——<code>stdio.o</code>（<code>printf</code>，<code>sprintf</code>，<code>vprintf</code>，<code>vsprintf</code>）、<code>string.o</code>（<code>mem</code> 系列和 <code>str</code> 系列）以及 <code>syscall_impl.o</code>（系统调用的实现部分）打成了一个库 <code>tulibc.a</code>，取 <code>TUtorialos LIBC</code> 的意思。<code>libc</code> 则是一种描述标准库的通用简写。然后，分别编译 <code>start.c</code> 和应用程序，最后把应用程序本体、<code>start.o</code> 和 <code>tulibc.a</code> 链接在一起，并设定入口点，形成可以让 TutorialOS 执行的应用程序。</p>
<p>当然，我们也是支持用汇编来编写应用程序的，这个流程就比较简洁，因为没有 <code>main</code> 的特殊包袱，直接编译链接即可。</p>
<p>下面编译硬盘映像的部分，我们也做了修改。</p>
<p><strong>代码 23-23 新的 Makefile（续）（Makefile）</strong>
<div class="highlight"><pre><span></span><code><span class="nv">APPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>out/test_c.bin

<span class="c"># 中略</span>

<span class="nf">hd.img </span><span class="o">:</span><span class="w"> </span><span class="n">out</span>/<span class="n">boot</span>.<span class="n">bin</span> <span class="n">out</span>/<span class="n">loader</span>.<span class="n">bin</span> <span class="n">out</span>/<span class="n">kernel</span>.<span class="n">bin</span> <span class="k">$(</span><span class="nv">APPS</span><span class="k">)</span>
<span class="w">    </span>ftimgcreate<span class="w"> </span>hd.img<span class="w"> </span>-t<span class="w"> </span>hd<span class="w"> </span>-size<span class="w"> </span><span class="m">80</span>
<span class="w">    </span>ftformat<span class="w"> </span>hd.img<span class="w"> </span>-t<span class="w"> </span>hd<span class="w"> </span>-f<span class="w"> </span>fat16
<span class="w">    </span>ftcopy<span class="w"> </span>out/loader.bin<span class="w"> </span>-to<span class="w"> </span>-img<span class="w"> </span>hd.img
<span class="w">    </span>ftcopy<span class="w"> </span>out/kernel.bin<span class="w"> </span>-to<span class="w"> </span>-img<span class="w"> </span>hd.img
<span class="w">    </span>ftcopy<span class="w"> </span>out/test_c.bin<span class="w"> </span>-to<span class="w"> </span>-img<span class="w"> </span>hd.img
<span class="w">    </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>out/boot.bin<span class="w"> </span><span class="nv">of</span><span class="o">=</span>hd.img<span class="w"> </span><span class="nv">bs</span><span class="o">=</span><span class="m">512</span><span class="w"> </span><span class="nv">count</span><span class="o">=</span><span class="m">1</span>
</code></pre></div></p>
<p>在 <code>what you need</code> 的部分，我们新添加了一个 <code>APPS</code> 变量，它代表我们需要编译的所有应用，目前只有一个 <code>test_c.bin</code>。编译出来以后，我们在下面的命令中进行写入。</p>
<p>现在应该就可以开始运行了。编译，运行，效果如下：</p>
<p><img alt="" src="../images/graph-23-3.png" />
（图 23-3 Hello, World!）</p>
<p>这一节实在是太长了，到此为止吧。下一节我们来支持 <code>malloc</code>，同时为应用程序传参，然后就可以正式结束啦！提前完结撒花.jpg</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
        <div class="md-copyright__highlight">
          本文档采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享 署名-相同方式共享 4.0 协议</a> 进行许可。
        </div>
        <div class="md-copyright__highlight">
          Copyright &copy; 2024 Oildum. Powered by mkdocs. Special thanks to copi143 for providing the theme and scripts.
        </div>
      </div>
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.tooltips", "navigation.instant", "navigation.instant.prefetch", "navigation.instant.progress", "navigation.instant.preview", "navigation.sections", "navigation.tracking", "navigation.tabs", "navigation.path", "navigation.indexes", "navigation.top", "toc.follow", "search.suggest", "search.highlight", "search.share"], "search": "../../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="../../../assets/MathJax.js"></script>
      
        <script src="../../../assets/script.js"></script>
      
    
  </body>
</html>